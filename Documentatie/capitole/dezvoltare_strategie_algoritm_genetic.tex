\section{Modelarea unui algoritm genetic pentru problema iterată a prizonierului}

\subsection{Reprezentarea soluției}

În urma organizării celor două turnee, Axelrod a decis să cerceteze dezvoltarea unei strategii pentru problema iterata a prizonierului, folosindu-se de algoritmii genetici introduși de Holland. 

Unul din cei mai importanți pași din acest proces a fost stabilirea unei modalități de a reprezenta o strategie în forma unui cromozom. Descriem concluziile lui Axelrod în rândurile următoare.

Presupunem că fiecare jucător are capacitatea de a memora mișcările ultimei runde sub forma unei perechi- primul element reprezintă mișcarea proprie, iar cel de al doilea element reprezintă mișcarea oponentului. Ne vom folosi de următoarea notație:

\begin{center}
	\textbf{C} reprezintă \textbf{cooperarea cu oponentul}\\
	\textbf{T} reprezintă \textbf{trădarea oponentului}   
\end{center}

Există patru perechi (sau cazuri) posibile:\\

\begin{center}
	Cazul 1: \textbf{CC}\\
	Cazul 2: \textbf{CT}\\
	Cazul 3: \textbf{TC}\\
	Cazul 4: \textbf{TT}\\
\end{center}

Pentru acest scenariu, strategia reprezintă ce mișcare vom alege, dat fiind aflarea mișcării oponentului în ultima rundă.

Strategia \textbf{Tit-for-Tat} este reprezentată în felul următor: 

\begin{center}
	dacă \textbf{CC} atunci \textbf{C}\\
	dacă \textbf{CT} atunci \textbf{T}\\
	dacă \textbf{TC} atunci \textbf{C}\\
	dacă \textbf{TT} atunci \textbf{T}\\
\end{center}

Dacă impunem ca aceste patru cazuri să respecte ordinea lexicografică, putem codifica strategia drept șirul de caractere \textbf{CTCT}. Ca să utilizăm această reprezentare a strategiei:\\
\begin{itemize}
	\item Observăm ce a ales oponentul în runda anterioară;
	\item Formăm perechea compusă din mișcarea noastră, împreună cu cea a oponentului;
	\item Vedem indexul care corespunde perechii obținute la pasul anterior;
	\item Alegem mișcarea pe care o găsim la indexul respectiv.
\end{itemize}

Strategiile lui Axelrod se bazau pe istoricul ultimelor trei runde. Pentru acestea, există 64 \footnote{64, sau $2^6$, reprezintă numărul de șiruri de caractere unice pe care le putem genera folosind doar caracterele \textbf{C} și \textbf{T}} de posibile scenarii pentru utlimele trei runde: 

\begin{center}
	Cazul 1: \textbf{CC CC CC}\\
	Cazul 2: \textbf{CC CC CT}\\
	Cazul 3: \textbf{CC CC TC}\\
	...
	\\
	Cazul 62: \textbf{TT TT CT}\\
	Cazul 63: \textbf{TT TT TC}\\
	Cazul 64: \textbf{TT TT TT}\\
\end{center}

Ca și în  ipoteza în care jucătorii memorează doar istoricul ultimei runde, putem reprezenta aceste cazuri într-un șir de caractere de lungime 64. Vom folosi un șir de caractere de lungime 71, pentru a reține și ce mișcări ar trebui făcute în primele runde, când încă nu există un istoric care să cuprindă ultimele trei runde. Cele 7 poziții de la începutul șirului de caractere au următoarele semnificații:\\

\begin{enumerate}
	
	\item La \textbf{poziția numărul 1} se găsește mișcarea aleasă pentru prima rundă a jocului;
	
	\item \textbf{Poziția numărul 2}: mișcarea pentru cea de a doua rundă, dacă la rundă anterioară oponentul a cooperat (\textbf{C} reprezintă istoricul mișcărilor oponentului);
	
	\item \textbf{Poziția numărul 3}: mișcarea pe care o vom face la cea de a două rundă, dacă la rundă anterioară oponentul a trădat (istoricul mișcărilor oponentului este scris sub forma \textbf{T});
	
	\item \textbf{Poziția numărul 4}: mișcarea pe care o vom face la cea de a două rundă, dacă pentru primele două runde, istoricul oponentului este \textbf{CC};
	
	\item \textbf{Poziția numărul 5}: mișcarea pentru cea de a treia rundă, dacă pentru primele două runde, istoricul oponentului este \textbf{CT};
	
	\item \textbf{Poziția numărul 6}: mișcarea pentru cea de a treia rundă, dacă pentru primele două runde, istoricul oponentului este \textbf{TC};
	
	\item \textbf{Poziția numărul 7}: mișcarea pentru cea de a treia rundă, dacă la primele două runde oponentul a avut mișcările \textbf{TT}.
	
\end{enumerate}

\subsection{Dimensiunea spațiului de căutare}

Având 71 de poziții pe care le putem ocupa cu cele două caractere- \textbf{C} sau \textbf{T}-, putem genera $2^{71}$ șiruri de caractere distincte. Acest număr reprezintă numărul tuturor strategiilor pe care îl putem avea, în contextul în care cunoaștem istoricul ultimelor trei runde ale jocului.  

Spațiul de căutare este, în concluzie, mult prea mare pentru a caută exhaustiv cea mai bună strategie.

\subsection{Funcția de optimizat}

Axelrod a alcătuit un set de opt strategii cu care să concureze fiecare strategie a algoritmului genetic, în vederea calculării unei funcții de optimizat. Acest set de strategii nu include strategia \textbf{Tit-for-Tat}. Valoarea funcției de optimizat este dată de media scorurilor obținute în urma meciurilor jucate cu fiecare dintre ele opt strategii.

\subsection {Parametrii algoritmului genetic}

Prin utilizarea unui algoritm genetic, pot obține o copie a celui mai bun individ din toate generațiile care au participat la antrenare. În alte cuvinte, acest cromozom conține strategia care a obținut cea mai bună valoare a funcției de optimizat. 

Pentru crearea acestui individ, este nevoie de ajustarea mai multor parametri și opțiuni, dintre care menționez: rata mutației, rata încrucisării, tipul selecției populației \footnote{Populația diferă ușor de la generație la generație, selectandu-se doar anumiți indivizi și în anumite proporții}. Cromozomul are capacitatea de a-și formula următoarea mișcare bazându-se pe istoricul ultimelor trei runde. Din acest motiv, este important ca un meci să fie format din mai multe runde. Așadar, numărul de runde reprezintă și acesta un parametru pentru antrenarea cromozomilor. 

\section {Elemente legate de implementarea solutiei}

-- CUM AM IMPLEMENTAT EU ACEASTĂ PROBLEMA

\subsection{Tehnologii folosite}

Ca și limbaj de programare, am ales să implementez soluția problemei folosind limbajul \textbf{Java}\cite{java}, care are o suită performantă de biblioteci. 
 
Pentru ca procesul de obținere a unei noi strategii să fie vizibil prin loguri, am apelat la biblioteca \textbf{SLF4J}\cite{slf4j}\footnote{Abrevierea provine de la Simple Logging Facade for Java.}. 
 
Pentru partea de vizualizarea a datelor, pentru a vedea cum evoluează strategiile pe parcursul unui turneu cu eliminare, am apelat la biblioteca integrată \textbf{JavaFX}\cite{javaFX}. 

Pentru manipulatea fișierelor json, am folosit biblioteca \textbf{json-simple}\cite{json-simple}.  

-- UȘURINȚA CU CARE SE POATE CREA O NOUĂ STRATEGIE

-- UNIT TESTS

\subsection{Implementarea algoritmului genetic}

Avem nevoie de 2 fișiere de configurare pentru stabilirea populației de antrenament și de test. În cadrul proiectului, se regăsesc sub denumirea de \textbf{testing.config.json} și \textbf{training.config.json}. Fișierele pot fi ușor manipulate prin clase specializate în citirea și scrierea lor.  
 
Toate strategiile dezvoltate prin intermediul algoritmului genetic sunt salvate într-un director de resurse, în fișiere în format json, alături de datele relevante pentru dezvoltarea cromozomilor: 
\begin{itemize}
	 \item[\textasteriskcentered] strategia rezultată 
  	 \item[\textasteriskcentered] o medie a scorului din turneul clasic 
  	 \item[\textasteriskcentered] numărul de runde jucate în fiecare meci 
  	 \item[\textasteriskcentered] configurația populației de antrenament 
  	 \item[\textasteriskcentered] numărul de generații 
  	 \item[\textasteriskcentered] dimensiunea populației antrenate
  	 \item[\textasteriskcentered] probabilitatea de încrucișare 
  	 \item[\textasteriskcentered] probabilitatea de mutație 
\end{itemize} 

Odată stabilită configurația parametrilor, se poate trece la inițializarea în mod aleator a cromozomilor și antrenarea lor.  

Timp de un număr de generații, cromozomii sunt supuși unor transformări: 
\begin{itemize} 
	\item se aplică un proces de selecție 
	\item se aplică operatorul încrucișării 
	\item se aplică mutația 
\end{itemize} 

\subsubsection{Selectia}

Procesul de selecție pe care am decis să îl implementez este selecția de tip ruletă \footnote{Engl. roulette wheel pool.}. Această selecție este un algoritm stocastic, în care indivizii sunt distribuiți pe niște segmente contigue. Lungimea segmentelor este direct proportională cu cât de bine este adaptat la mediu individul. Fiecare segment determină un interval. Se generează pe rând câte un număr aleator și este ales intervalul (care corespunde unui unic individ-practic se alege individul) la care aparține numărul. Individul selectat se adaugă în mulțimea ce va înlocui, la finalul selecției, generația actuală. Procesul seamănă cu învârtirea ruletei, unde fiecare felie a ruletei are mărimea direct proportională cu gradul de adecvare\footnote{Paragraf adaptat după Cursul de \textit{Tehnici de inteligentă computatională în electronică}, Prof.dr.ing. Gabriel Oltean, Universitatea Tehnică din Cluj-Napoca.}.  

--- DE ADAUGAT O IMAGINE   

\subsubsection{Incrucisarea si mutatia}


\subsection {Limitările algoritmului genetic} -- poate ca urmare a turneelor sau ca urmare a mediei functiei fitness?...

- care sunt limitările unui algoritm genetic aplicat pe această problema?

-- schimbarea valorilor parametrilor

-- OBSERVAȚII CLARE OBȚINUTE ÎN URMĂ UNOR EXPERIMENTE legat de modul în care parametrii influențează calitatea soluțiilor
